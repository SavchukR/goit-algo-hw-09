# Summary

Продуктивність алгоритму на базі greedy набагато краща ніж продуктивність в динамічному програмуванні.

```python
find_coins_greedy(25720395, nominals=[1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 5000])
```

Для 20 запусків
Total time : 6429.0 ns

```python
find_min_coins(25720395, nominals=[1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 5000])
```
Для одного запуску навіть алгоритм пошуку на базі динамічного програмування
Total time : 99935331856.0 ns

Причиною є складність алгоритму з точки зору пам'яті і перебору всіх оптимальних варіантів в випадку динамічного програмування, оскільки для дуже великих чисел алгоритм намагається підібрати всі можливі комбінаціх і це займає час.

Складність першого алгоритму - O(n) - n - кількість номіналів
Складність другого алгоритму - O(n * m) - n - кількість номіналів m - сума, що є визначальним чинником що сповільнює роботу для великих сум

Дана задача не пояснює повністю що від алгоритмів динамічного програмування треба відмовитись.
Завжди треба обирати між швидкою майже правильною відповідю (greedy) і трошки довшою але більш оптимальною
